### Сериализация
   ## 1. Что такое сериализация?
    Сериализация — это процесс сохранения состояния объекта в последовательность байт.
    Десериализация — это процесс восстановления объекта из этих байт.

## 2. Serializable
Для того, чтобы объекты класса могли быть подвергнуты процессу сериализации, этот класс должен расширять интерфейс java.io.Serializable. Не имеет методов.
    Стандартная сериализация, с использованием java.io.Serializable работает через Reflection API. Т.е. класс разбирается как набор полей, каждое из которых пишется в выходной поток.
    При использовании Serializable десериализация происходит так: под объект выделяется память, после чего его поля заполняются значениями из потока. Конструктор объекта при этом не вызывается.
    Спецификаторы transient и static означают, что поля, помеченные ими, не могут быть предметом сериализации, но существует различие в десериализации. Так, поле со спецификатором transient после десериализации получает значение по умолчанию, соответствующее его типу (объектный тип всегда инициализируется по умолчанию значением null), а поле со спецификатором static получает значение по умолчанию в случае отсутствия в области видимости объектов своего типа, а при их наличии получает значение, которое определено для существующего объекта.
## 3. Externalizable
Интерфейса java.io.Externalizable содержит два метода, которые необходимо реализовать – writeExternal(ObjectOutput) и readExternal(ObjectInput)
    При использовании Externalizable десериализация происходит: сначала вызывается конструктор без параметров, а потом уже на созданном объекте вызывается метод readExternal, который и вычитывает, собственно, все свои данные. Потому – любой реализующий интерфейс Externalizable класс обязан иметь public конструктор без параметров! Более того, поскольку все наследники такого класса тоже будут считаться реализующими интерфейс Externalizable, у них тоже должен быть конструктор без параметров!
    При использовании Externalizable никто не мешает сериализовать поле static, равно как и вычитать его. Если поле объявлено transient, то при десериализации объекта, оно принимает значение по умолчанию. Поля с модификатором final  – их невозможно десериализовать при использовании Externalizable.
## 4. SerialVersionUID
При сериализации объекта класса, реализующего интерфейс Serializable, учитывается порядок объявления полей в классе. Поэтому при изменении порядка, имен и типов полей или добавлении новых полей в класс структура информации, содержащейся в сериализованном объекте, будет серьезно отличаться от новой структуры класса. Поэтому десериализация может пройти некорректно. Этим обусловлена необходимость добавления программистом в каждый класс, реализующий интерфейс Serializable, поля private static final long serialVersionUID на стадии разработки класса. Это поле содержит уникальный идентификатор версии сериализованного класса. Оно вычисляется по содержимому класса — полям, их порядку объявления, методам, их порядку объявления. Для этого применяются специальные программы-генераторы UID. Это поле записывается в поток при сериализации класса. Это единственный случай, когда static-поле сериализуется. При десериализации значение этого поля сравнивается с имеющимся у класса в виртуальной машине. Если значения не совпадают, инициируется исключение java.io.InvalidClassException. Соответственно, при любом изменении в первую очередь полей класса значение поля serialVersionUID должно быть изменено программистом или генератором.
## 5. Сериализация и наследование
##  Serializable.
   a. Когда класс имеет цепочку родителей, пока эти родители тоже Serializable, десериализация объекта идет от родителя к наследнику, в обход конструктора. Вместо него вызываются методы readObject (readObjectNoData). Но как только встречается первый предок, не реализующий интерфейс Serializable, инициализация для него возвращается в нормальное русло – вместо readObject вызывается конструктор без аргументов. Если такого конструктора нет, или он объявлен private, исполнение выбросит InvalidClassException.
   b. При наследовании от класса, реализующего Serializable, никаких дополнительных действий предпринимать не надо. Сериализация будет распространяться и на дочерний класс.
 Externalizable
   a. При наследовании от класса, реализующего Externalizable, необходимо переопределить методы родительского класса readExternal и writeExternal. Иначе поля дочернего класса сериализованы не будут. В этом случае надо вызвать родительские методы, иначе не сериализованы будут уже родительские поля.
  ## 6. Сериализация и композиция
   При сериализации объекта сериализуются все объекты, на которые он ссылается в своих переменных экземпляра. И если те объекты тоже ссылаются на третьи объекты, они тоже сериализуются. И так до бесконечности. Все классы в этой цепочке должны быть Serializable, иначе их невозможно будет сериализовать и будет выброшено исключение.
  ## 7. Способы управления процессом сериализации
## Serializable.
   Если у сериализуемого объекта реализован один из следующих методов, то механизм сериализации будет использовать его, а не метод по умолчанию :
   writeObject - запись объекта в поток;
   readObject - чтение объекта из потока;
   writeReplace - позволяет заменить себя экземпляром другого класса перед записью;
   readResolve - позволяет заменить на себя другой объект после чтения.
   FileOutputStream outputStream = new FileOutputStream("fileName");
   ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);       objectOutputStream.writeObject(savedGame);
2. Externalizable
   Переопределить метод - writeExternal(ObjectOutput)
