## 1.1. What is Spring Framework? Different features.
Spring framework - это Java платформа с открытым исходным кодом, которая обеспечивает комплексную поддержку инфраструктуры для очень простой и быстрой разработки надежных Java приложений.
Spring Framework предоставляет комплексную модель программирования и конфигурации для современных корпоративных приложений на основе Java - на любой платформе развертывания.
Ключевым элементом Spring является инфраструктурная поддержка на уровне приложений: Spring фокусируется на «соединении» корпоративных приложений, так что команды могут сосредоточиться на бизнес-логике уровня приложения без ненужных привязок к конкретным средам развертывания.
Spring можно использовать для построения любого приложения на языке Java (т.е. автономных, веб приложений, приложений JEE и т.д.). Платформа Spring является облегченной в том смысле, что для использования ядра Spring вы должны вносить минимальные (если вообще какие-либо) изменения в код своего приложения.

Features
Core technologies: dependency injection, events, resources, i18n, validation, data binding, type conversion, SpEL, AOP.
Testing: mock objects, TestContext framework, Spring MVC, Test, WebTestClient.
Data Access: transactions, DAO support, JDBC, ORM, Marshalling XML.
Spring MVC and Spring WebFlux web frameworks.
Integration: remoting, JMS, JCA, JMX, email, tasks, scheduling, cache.
Languages: Kotlin, Groovy, dynamic languages.
## 1.2. Overview of Spring modules.

       	Основной контейнер (Core Container) включает в себя Beans, Core, Context и SpEL (expression language).
Beans отвечает за BeanFactory которая является сложной реализацией паттерна Фабрика (GoF).
Модуль Core обеспечивает ключевые части фреймворка, включая свойства IoC и DI.
Context построен на основе Beans и Core и позволяет получить доступ к любому объекту, который определён в настройках. Ключевым элементом модуля Context является интерфейс ApplicationContext.
Модуль SpEL обеспечивает мощный язык выражений для манипулирования объектами во время  исполнения.

Контейнер Data Access/Integration состоит из JDBC, ORM, OXM, JMS и модуля Transactions.
JDBC обеспечивает абстрактный слой JDBC и избавляет разработчика от необходимости вручную прописывать монотонный код, связанный с соединением с БД.
ORM обеспечивает интеграцию с такими популярными ORM, как Hibernate, JDO, JPA и т.д.
Модуль OXM отвечает за связь Объект/XML – XMLBeans, JAXB и т.д.
Модуль JMS (Java Messaging Service) отвечает за создание, передачу и получение сообщений.
Transactions поддерживает управление транзакциями для классов, которые реализуют определенные методы.

Слой Web состоит из Web, Web-MVC, Web-Socket, Web-Portlet
Модуль Web обеспечивает такие функции, как загрузка файлов и т.д.
Web-MVC содержит реализацию Spring MVC для веб-приложений.
Web-Socket обеспечивает поддержку связи между клиентом и сервером, используя Web-Socket-ы в веб-приложениях.
Web-Portlet обеспечивает реализацию MVC в среде портлетов.
Spring также включает в себя ряд других важных модулей, таких как AOP, Aspects, Instrumentation, Messaging и Test
AOP реализует объектно-ориентированное программирование и позволяет использовать весь арсенал возможностей АОП.
Модуль Aspects обеспечивает интеграцию с AspectJ, которая также является мощным фреймворком АОП.
Instrumentation отвечает за поддержку class instrumentation и classloader, которые используются в серверных приложениях.
Модуль Messaging обеспечивает поддержку STOMP.
Модуль Test обеспечивает тестирование с использованием TestNG или JUnit Framework.
## 1.3. Spring core container overview.
Основной контейнер (Core Container) включает в себя Beans, Core, Context и SpEL (expression language).
Beans отвечает за BeanFactory которая является сложной реализацией паттерна Фабрика.
Модуль Core обеспечивает ключевые части фреймворка, включая свойства IoC и DI.
Context построен на основе Beans и Core и позволяет получить доступ к любому объекту, который определён в настройках. Ключевым элементом модуля Context является интерфейс ApplicationContext.
Модуль SpEL обеспечивает мощный язык выражений для манипулирования объектами во время исполнения.
## 1.4. Spring configuration file.
Spring configuration file - это XML-файл конфигурации Spring, который содержит всю информацию о различных типах классов и о том, как они соотносятся друг с другом.

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:context="http://www.springframework.org/schema/context"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context-3.0.xsd ">
<bean id="beanId" class=«com.company.MyClass»/>
<context:annotation-config/>
</beans>
## 1.5. Spring IoC Container overview.
Ключевым элементом Spring Framework является Spring Container. Container создаёт объекты, связывает их вместе, настраивает и управляет их полным жизненным циклом от создания до момента уничтожения.
Для управления компонентами, из которых состоит приложение, Spring Container использует Внедрение Зависимостей (DI). Эти объекты называются Spring Beans.
Spring Container получает инструкции какие объекты инстанциировать и как их конфигурировать через метаданные.

Метаданные могут быть получены 3 способами:
– XML
– Аннотации Java
– Java код
В Spring имеется 2 различных вида контейнеров:
1. Spring BeanFactory Container;
2. Spring ApplicationContext Container;
   ## 1.6. Dependency Injection.
   Внедрение зависимости (Dependency injection, DI) — процесс предоставления внешней зависимости программному компоненту. Является специфичной формой «инверсии управления» (Inversion of control, IoC), когда она применяется к управлению зависимостями. В полном соответствии с принципом единой обязанности объект отдаёт заботу о построении требуемых ему
   зависимостей внешнему, специально предназначенному для этого общему механизму.
   Реализация DI в Spring основана на двух ключевых концепциях Java — компонентах JavaBean и интерфейсах. Компоненты JavaBean (также называемые POJO (Plain Old Java Object — простой старый объект Java)) предоставляют стандартный механизм для создания ресурсов Java, которые являются конфигурируемыми множеством способов. За счет применения DI объем кода, который необходим при проектировании приложения на основе интерфейсов, снижается почти до нуля. Кроме того, с помощью интерфейсов можно получить максимальную отдачу от DI, потому что бины могут использовать любую реализацию интерфейса для удовлетворения их зависимости.

К типам реализации внедрения зависимостей в Spring относят:
Constructor Dependency Injection
Setter Dependency Injection
## 1.7. Constructor injection vs setter injection vs interface injection.
Constructor Dependency Injection — это тип внедрения зависимостей, при котором зависимости компонента предоставляются ему в его конструкторе (или конструкторах).
Setter Dependency Injection – контейнер IoC внедряет зависимости компонента в компонент через методы установки в стиле JavaBean.
## 1.8. BeanFactory vs ApplicationContext.
1. Spring BeanFactory Container
   Это самый простой контейнер, обеспечивающий базовую поддержку DI и который основан на интерфейсе org.springframework.beans.factory.BeanFactory. Такие интерфейсы, как BeanFactoryAware и DisposableBean всё ещё присутствуют в Spring для обеспечения обратной совместимости.
   Наиболее часто используемая реализация интерфейса BeanFactory – XmlBeanFactory.
   XmlBeanFactory получает метаданные из конфигурационного XML файла и использует его для создания настроенного приложения или системы.
   BeanFactory обычно используется тогда, когда ресурсы ограничены (мобильные устройства). Поэтому, если ресурсы не сильно ограничены, то лучше использовать ApplicationContext.
2. Spring ApplicationContext Container
   ApplicationContext является более сложным и более продвинутым Spring Container-ом. Так же, как BeanFactory, ApplicationContext загружает бины, связывает их вместе и конфигурирует их определённым образом. Но кроме этого, ApplicationContext обладает дополнительной функциональностью: распознание текстовых сообщений из файлов настройки и отображение событий, которые происходят в приложении различными способами. Этот контейнер определяется интерфейсом org.springframework.context.ApplicationContext.
   Разница:
   BeanFactory загружает bean-компоненты по запросу (Lazy Loading), а ApplicationContext загружает все bean-компоненты при запуске (Eager Loading).
   ApplicationContext расширяет BeanFactory в более ориентированном на фреймворк стиле и предоставляет несколько функций, подходящих для корпоративных приложений. Например, он обеспечивает функциональность обмена сообщениями (i18n или интернационализацию), функциональность публикации событий, внедрение зависимостей на основе аннотаций и простую интеграцию с функциями Spring AOP.
   ApplicationContext поддерживает почти все типы областей действия bean-компонентов, но BeanFactory поддерживает только две области - Singleton и Prototype.
   ApplicationContext автоматически регистрирует BeanFactoryPostProcessor и BeanPostProcessor при запуске. С другой стороны, BeanFactory не регистрирует эти интерфейсы автоматически.
 ##   1.9. Benefits of IoC.
   Преимущества IOC (внедрение зависимостей) заключаются в следующем:
   Сводит к минимуму количество кода в приложении. С контейнерами IOC вам не нужно заботиться о том, как создаются сервисы и как вы получаете ссылки на те, которые вам нужны. Вы также можете легко добавить дополнительные службы, добавив новый конструктор или метод установки с небольшой дополнительной конфигурацией или без нее.
   Сделайте ваше приложение более тестируемым. Контейнеры IOC очень упрощают модульное тестирование и переключение реализаций, позволяя вручную вводить собственные объекты в тестируемый объект.
   Слабое сцепление (Loose coupling) достигается с минимальными усилиями и с наименьшим вмешательством механизма. Шаблон проектирования фабрики более навязчив, потому что компоненты или службы нужно запрашивать явно, тогда как в IOC зависимость вводится в запрашивающий фрагмент кода. Также некоторые контейнеры продвигают дизайн к интерфейсам, а не к концепции проекта реализации, поощряя управляемые объекты к реализации четко определенного интерфейса службы вашего собственного.
   Контейнеры IoC поддерживают активное создание экземпляров (eager instantiation) и отложенную загрузку (lazy loading) сервисов. Контейнеры также обеспечивают поддержку создания экземпляров управляемых объектов, циклических зависимостей, управления жизненными циклами и разрешения зависимостей между управляемыми объектами и т. д.
 ##   1.10. What is Spring Bean?
   Бины – это объекты, которые являются основой приложения и управляются Spring IoC контейнером. Эти объекты создаются с помощью конфигурационных метаданных, которые указываются в контейнере (например, XML- <bean>…</bean>).
   Определение бина содержит метаданные конфигурации, которые необходимы управляющему контейнеру для получения следующей информации:
   Как создать бин;
   Информацию о жизненном цикле бина;
   Зависимости бина.
   В Spring Framework существуют такие свойства, определяющие бины:
   class - Этот атрибут является обязательным и указывает конкретный класс Java-приложения, который будет использоваться для создания бина.
   name - Уникальный идентификатор бина. В случае конфигурации с помощью xml-файла, вы можете использовать свойство “id” и/или “name” для идентификации бина.
   scope - Это свойство определяет область видимости создаваемых объектов.
   constructor-arg - Определяет конструктор, использующийся для внедрения зависимости.
   properties - Определяет свойства внедрения зависимости.
   initialization method - Здесь определяется метод инициализации бина
   destruction method - Метод уничтожения бина, который будет использоваться при уничтожении контейнера, содержащего бин.
   autowiring mode - Определяет режим автоматического связывания при внедрении зависимости.
   lazy-initialization mode - Режим ленивой инициализации даёт контейнеру IoC команду создавать экземпляр бина при первом запросе, а не при запуске приложения.
  ##  1.11. XML-based vsAnnotation-based vs Java-based configuration.
   XML-based – Используйте конфигурации на основе XML, если вы знаете, что вам может потребоваться изменить поведение приложения без необходимости повторной компиляции и развертывания кода.
   Annotation-based – Annotation injection выполняется до XML injection. Таким образом, последняя конфигурация переопределит предыдущую для свойств, связанных с обоими подходами.
   Annotation wiring не включено в контейнере Spring по умолчанию. Итак, прежде чем мы сможем использовать annotation-based wiring, нам нужно будет включить ее в нашем файле конфигурации Spring.
   <context:annotation-config/>
   @Required
   @Autowired
   @Qualifier
   @PostConstruct
   @PreDestroy
   @Resource

Java Based
@Configuration - Аннотирование класса с помощью @Configuration  указывает, что класс может использоваться контейнером Spring IoC в качестве источника определений bean-компонентов.
@Bean - Аннотация @Bean сообщает Spring, что метод, аннотированный с помощью @Bean, вернет объект, который должен быть зарегистрирован как bean-компонент в контексте приложения Spring.
@Import - Аннотация @Import позволяет загружать определения @Bean из другого класса  конфигурации.

@Configuration
public class
HelloWorldConfig {
@Bean
public HelloWorld helloWorld() {
return new HelloWorld();
}
}

ApplicationContext ctx = new AnnotationConfigApplicationContext(HelloWorldConfig.class);
HelloWorld helloWorld = ctx.getBean(HelloWorld.class);
## 1.12.  Bean Scopes overview, comparison.
В Spring предусмотрены различные области времени действия бинов:
singleton – может быть создан только один экземпляр бина. Этот тип используется спрингом по умолчанию, если не указано другое. Следует осторожно использовать публичные свойства класса, т.к. они не будут потокобезопасными.
prototype – создается новый экземпляр при каждом запросе.
request –  аналогичен prototype, но название служит пояснением к использованию бина в веб приложении. Создается новый экземпляр при каждом HTTP request.
session – новый бин создается в контейнере при каждой новой HTTP сессии.
global-session: используется для создания глобальных бинов на уровне сессии для Portlet  приложений.
application - Включает одно определение bean-компонента в жизненный цикл ServletContext. Действителен только в контексте Spring ApplicationContext, поддерживающего веб-интерфейс.
websocket - Включает определение одного компонента в жизненный цикл WebSocket. Допустимо
только в контексте Spring ApplicationContext, поддерживающего веб-интерфейс.
## 1.13. Bean life cycle in Spring bean factory.
Через следующие этапы проходит каждый отдельно взятый бин:
Инстанцирование объекта. Техническое начало жизни бина, работа конструктора его класса;
Установка свойств из конфигурации бина, внедрение зависимостей;
Нотификация aware-интерфейсов. BeanNameAware, BeanFactoryAware и другие. Технически, выполняется системными подтипами BeanPostProcessor, и совпадает с шагом 4;
Пре-инициализация – метод postProcessBeforeInitialization() интерфейса BeanPostProcessor;
Инициализация. Разные способы применяются в таком порядке:
o   Метод бина с аннотацией @PostConstruct из стандарта JSR-250 (рекомендуемый способ);
o   Метод afterPropertiesSet() бина под интерфейсом InitializingBean;
o Init-метод. Для отдельного бина его имя устанавливается в параметре определения initMethod. В xml-конфигурации можно установить для всех бинов сразу, с помощью default-init-method;
Пост-инициализация – метод postProcessAfterInitialization() интерфейса BeanPostProcessor.
Когда IoC-контейнер завершает свою работу, мы можем кастомизировать этап штатного уничтожения бина. Как со всеми способами финализации в Java, при жестком выключении (kill -9) гарантии вызова этого этапа нет. Три альтернативных способа «деинициализации» вызываются в том же порядке, что симметричные им методы инициализации:
Метод с аннотацией @PreDestroy;
Метод с именем, которое указано в свойстве destroyMethod определния бина (или в глобальном default-destroy-method);
Метод destroy() интерфейса DisposableBean.
## 1.14. Inner beans in Spring.
Внутренние bean-компоненты - это bean-компоненты, которые определены в рамках другого bean-компонента. Таким образом, элемент <bean /> внутри элементов <property /> или <constructor-arg /> называется внутренним компонентом.

 <bean id = "outerBean" class = "...">
      <property name = "target">
 <bean id = "innerBean" class = "..."/>
      </property>
 </bean>
## 1.15.  Autowiring in Spring, limitations.
        	Spring Framework позволяет осуществлять автоматическое связывание бинов (autowiring).
Существует несколько режимов автоматического связывания в Spring:

(пусто) – Этот режим установлен по умолчанию и означает отсутствие автоматического связывания. Т.е. мы должны использовать прямую ссылку на бин для связывания.
byName – Используется автоматической связывание по имени бина. Контейнер Spring ищет в XML файле бин с указанным именем. И если находит бин с таким же именем – производит автоматическое связывание.
byType – Автоматическое связывание по типу. В этом случае контейнер Spring ищет совпадение по типу. В случае, если он находит – происходит автоматическое связывание. Если в XML-файле определены несколько бинов с таким типом, то мы получаем исключение (exception).
Constructor – Здесь всё происходит так же, как и при использовании режима ‘byType’, с тем отличием, что поиск идёт по аргументам конструктора. Если в XML-файле находится несколько таких бинов – мы получаем ошибку (error).
Autodetect – В этом режиме сначала происходит связывание в режиме ‘constructor’, а затем (если автосвязывание не произошло) в режиме ‘byType’.
## 1.16. Annotation-based container configuration.
## 1.17. Differences between @Component, @Repository, @Service and @Controller.
Есть несколько способов настроить bean-компоненты в контейнере Spring. Мы можем объявить их, используя конфигурацию XML. Мы можем объявить bean-компоненты с помощью аннотации @Bean в классе конфигурации. Или мы можем пометить класс одной из аннотаций из пакета org.springframework.stereotype, а остальное оставить сканированию компонентов.
@ComponentScan настраивает, какие пакеты сканировать на предмет классов с конфигурацией аннотации.
<context:component-scan
base-package="com.baeldung" />
@Component - это аннотация уровня класса. Во время сканирования компонентов Spring Framework автоматически обнаруживает классы, помеченные @Component.
@Repository, @Service, @Controller - все это метааннотации @Component
@Repository – Классы DAO или Repository обычно представляют уровень доступа к базе данных в приложении и должны быть аннотированы с помощью @Repository.
Одним из преимуществ использования этой аннотации является то, что в ней включена автоматическая трансляция исключений сохраняемости. При использовании среды сохранения, такой как Hibernate, собственные исключения, создаваемые в классах, аннотированных с помощью @Repository, будут автоматически транслироваться в подклассы Spring DataAccessExeption.

@Service – Бизнес-логика приложения обычно находится на уровне сервиса, поэтому нужно использовать аннотацию @Service, чтобы указать, что класс принадлежит этому уровню.
@Controller – это аннотация уровня класса, которая
сообщает Spring Framework, что этот класс служит контроллером в Spring MVC.
## 1.18. @Required vs @Autowired vs @Qualifier annotations.
@Required – Аннотация @Required применяется к методам установки свойств bean-компонента и указывает, что затронутое свойство bean-компонента должно быть заполнено в файле конфигурации XML во время настройки. В противном случае контейнер выдает исключение BeanInitializationException.

@Autowired – Аннотация @Autowired обеспечивает более детальный контроль над тем, где и как должно выполняться автоматическое подключение (autowiring). Аннотацию @Autowired можно использовать для автонастройки bean-компонента в методе установки точно так же, как аннотацию @Required, конструктор, свойство или методы с произвольными именами и/или несколькими аргументами.
Когда Spring находит аннотацию @Autowired, используемую с методами установки, он пытается выполнить автоматическое подключение byType к методу.
По умолчанию аннотация @Autowired подразумевает, что требуется зависимость, аналогично аннотации @Required, однако вы можете отключить поведение по умолчанию, используя параметр (required = false) с @Autowired.

@Qualifier – Может возникнуть ситуация, когда вы создаете более одного bean-компонента одного типа и хотите связать только один из них со свойством. В таких случаях вы можете использовать аннотацию @Qualifier вместе с @Autowired, чтобы устранить путаницу, указав, какой именно компонент будет подключен.
## 1.19. @Transactional annotations.   
@EnableTransactionManagement - Аннотация для включения поддержки транзакций, или

 <bean id="txManager" class="org.springframework.orm.jpa.JpaTransactionManager">
<property name="entityManagerFactory" ref="myEmf" />
</bean>
<tx:annotation-driven transaction-manager="txManager" />
         	Теперь можно аннотировать bean-компонент с помощью @Transactional либо на уровне класса, либо на уровне метода:
Аннотация также поддерживает дальнейшую настройку:
Propagation Type - Тип распространения транзакции
Isolation Level - Уровень изоляции транзакции
Timeout - Тайм-аут для операции, заключенной в транзакцию
флаг readOnly - подсказка поставщику постоянства, что транзакция должна быть доступна только для чтения
Rollback
- Правила отката для транзакции
        	На высоком уровне Spring создает прокси для всех классов, аннотированных @Transactional, либо для класса, либо для любого из методов. Прокси-сервер позволяет платформе внедрять транзакционную логику до и после запущенного метода, в основном для запуска и фиксации транзакции.

## 20. What's new in Spring Framework 5.0?. 
Functional Web Framework, Kotlin и и поддержка реактивного программирования.
##  Spring Boot
## 1. What is Spring Boot? The main purpose
        	Spring Boot — это среда на основе Java с открытым исходным кодом, используемая для создания микросервиса.
        	Micro Service — это архитектура, которая позволяет разработчикам самостоятельно разрабатывать и развертывать сервисы. Каждый работающий сервис имеет свой собственный процесс, и это обеспечивает облегченную модель для поддержки бизнес-приложений.
        	Spring Boot предоставляет хорошую платформу для разработчиков Java для разработки автономного и производительного Spring-приложения, которое можно просто запустить. Можно начать работу с минимальными настройками без необходимости полной настройки конфигурации Spring.
Преимущества:
Легко понять и разработать Spring-приложения
Увеличивает производительность
Сокращает время разработки
Цели:
Чтобы избежать сложной конфигурации XML в Spring
Разрабатывать готовые приложения Spring проще
Сократить время разработки и запустить приложение самостоятельно
Предлогает более простой способ начать работу с приложением
Чем полезен:
Он предоставляет гибкий способ настройки Java Beans, конфигураций XML и транзакций базы данных.
Он обеспечивает мощную пакетную обработку и управляет конечными точками REST.
В Spring Boot все настраивается автоматически; ручные настройки не требуются.
Это предлагает основанное на аннотации Spring заявление
Облегчает управление зависимостями
Включает встроенный контейнер сервлетов
## 2 The minimum requirements for a Spring boot System
Spring Boot автоматически настраивает ваше приложение на основе зависимостей, которые добавлены в проект, используя аннотацию @EnableAutoConfiguration . Например, если база данных MySQL находится на пути к классам, но не настроено соединение с базой данных, Spring Boot автоматически конфигурирует базу данных в памяти.
Точка входа Spring Boot Application — класс, содержащий аннотацию @SpringBootApplication. Этот класс должен иметь основной метод для запуска приложения Spring Boot. Аннотация @SpringBootApplication включает автоконфигурацию , сканирование компонентов и конфигурацию Spring Boot.
        	Если вы добавили аннотацию @SpringBootApplication в класс, вам не нужно добавлять аннотации @EnableAutoConfiguration, @ComponentScan и @SpringBootConfiguration. Аннотация @SpringBootApplication включает в себя все остальные примечания.
## 3. The steps to create a Spring Boot project using Spring Initializer
Одним из способов начальной загрузки приложения Spring Boot является использование Spring Initializer. Для этого нужно посетить веб-страницу Spring Initializer www.start.spring.io и выбрать версию сборки, Spring Boot и платформу. Кроме того, нужно предоставить Group, Artefact и необходимые зависимости для запуска приложения.
## 4. When the system gets overloaded
## 5. What are the @RequestMapping and @RestController annotation in Spring Boot used for?
Аннотация @RequestMapping используется для мапинга (связывания) с URL для всего класса или для конкретного метода обработчика.
Аннотация Controller определяет класс как Контроллер Spring MVC.
Аннотация @RestController в Spring MVC — это не что иное, как сочетание аннотации @Controller и @ResponseBody . Он был добавлен в Spring 4.0 для упрощения разработки веб-служб RESTful в среде Spring.
 	Задача @Controller — создать карту объекта модели и найти представление, но @RestController просто возвращает объект, и данные объекта напрямую записываются в HTTP-ответ в виде JSON или XML.
	Это также можно сделать с помощью традиционного @Controller и использования аннотации @ResponseBody но так как это стандартное поведение веб-сервисов RESTful, Spring представил @RestController который сочетал в себе поведение @Controller и @ResponseBody .
## 6. What is Spring Boot CLI and how to execute the Spring Boot project using boot CLI?
Spring Boot CLI — это инструмент командной строки, который позволяет нам запускать скрипты Groovy. Это самый простой способ создать приложение Spring Boot с помощью интерфейса командной строки Spring Boot. Вы можете создавать, запускать и тестировать приложение в самой командной строке.
## 7.  What do you understand by auto-configuration in Spring Boot and how to disable the auto-configuration?
Автоматическая настройка Spring Boot автоматически настраивает приложение Spring на основе зависимостей JAR, добавленных в проект.
        	Если вы обнаружите, что применяются определенные автоматически настраиваемые классы, которые вам не нужны, вы можете использовать атрибут exclude @EnableAutoConfiguration, чтобы отключить их.
@Configuration
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
public class MyConfiguration {
}
## 8. Can we create a non-web application in Spring Boot?
@SpringBootApplication
public class SpringBootConsoleApplication implements CommandLineRunner {
     public static void main(String[] args) throws Exception {
        SpringApplication.run(SpringBootConsoleApplication.class, args);
}
    //access command line arguments
    @Override
    public void run(String... args) throws Exception {
        //do something
	}
}
## 9. Spring vs Spring boot
Преимущества Spring Framework
Spring Framework может быть задействован на всех архитектурных слоях, применяемых при при разработке web-приложений
Использует модель POJO при написании классов, а это очень легкая структура
Позволяет свободно связывать модули и легко их тестировать
Поддерживает декларативное программирование
Избавляет от самостоятельного создания фабричных и синглтон-классов
Поддерживает различные способы конфигурации
Предоставляет сервис уровня middleware
         	Несмотря на наличие стольких преимуществ, которыми обладает Spring, длительная процедура подготовки, связанная с его настройкой, способствовала появлению Spring Boot.
 Преимущества Spring Boot
        	Spring Boot упрощает использование Spring Framework. Spring обеспечивает слабо связанное приложение — это отличная функция. Однако, когда есть несколько слабо связанных блоков, отслеживание их становится утомительной и неблагодарной задачей. Тут-то Spring Boot и помогает упростить все, не предлагая никакой функции конфигурации.
Spring Boot не требует развертывания war-файлов
Создает автономные приложения
Помогает напрямую встроить в приложение Tomcat, Jetty или Undertow
Не требует XML-конфигурации
Направлен на уменьшение объема исходного кода
Имеет дополнительную функциональность «из коробки»
Простота запуска
Простая настройка и управление
        	Благодаря таким функциям, как автоконфигурация, Spring Boot избавляет вас от написания лишнего кода и помогает избежать ненужной настройки.
## 10. Advantages and disadvantages of Spring boot. 
Преимущества Spring Boot
Spring Boot создан, чтобы помочь программистам ускорить процесс разработки. Он позволяет избавиться от трудоемкой первоначальной установки и настройки среды развертывания. 
Основные преимущества Spring Boot:
Быстрая и легкая разработка приложений на основе Spring.
Автоконфигурация всех компонентов для приложения Spring производственного уровня.
Готовые встроенные серверы (Tomcat, Jetty и Undertow), обеспечивающие ускоренное и более продуктивное развертывание приложений.
HTTP end-points, позволяющие вводить внутренние функции приложения, такие как показатели, состояние здоровья и другие.
Отсутствие конфигурации XML.
Огромный выбор плагинов, облегчающих работу разработчиков со встроенными базами данных и базами данных в памяти.
Легкий доступ к базам данных и службам очередей, таким как MySQL, Oracle, MongoDB, Redis, ActiveMQ и другим.
Плавная интеграция с экосистемой Spring.
 Большое сообщество и множество обучающих программ, облегчающих ознакомительный период.
Недостатки Spring Boot
Отсутствие контроля. Spring Boot создает множество неиспользуемых зависимостей, что приводит к большому размеру файла развертывания.
Сложный и трудоемкий процесс преобразования устаревшего или существующего проекта Spring в приложения Spring Boot.
Не подходит для масштабных проектов. По мнению многих разработчиков, несмотря на отсутствие проблем при работе с микросервисами, Spring Boot не подходит для создания монолитных приложений.
