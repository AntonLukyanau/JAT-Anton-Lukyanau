##  Рефлексия в Java
## 1. Что такое рефлексия?
    Рефлексия (от reflexio - обращение назад) - это механизм исследования данных о программе во время её выполнения. Рефлексия в Java осуществляется с помощью Java Reflection API, состоящий из классов пакетов java.lang и java.lang.reflect. В информатике рефлексия означает процесс, во время которого программа может отслеживать и модифицировать собственную структуру и поведение во время выполнения.
    Рефлексия позволяет:
    получать информацию о переменных, методах внутри класса, о самом классе, его конструкторах, реализованных интерфейсах и т.д.;
    получать новый экземпляр класса;
    получать доступ ко всем переменным и методам, в том числе private;
    преобразовывать классы одного типа в другой (cast);
    делать все это во время исполнения программы (динамически, в Runtime).
    Минусы Рефлексии:
    Худшая производительность в сравнении с классической работой с классами, методами и переменными;
    Ограничения безопасности. Если мы захотим использовать рефлексию на классе, который защищен с помощью специального класса SecurityManager, то ничего у не выйдет т.к. этот класс будет выбрасывать исключения каждый раз, как мы попытаемся получить доступ к закрытым членам класса. Такая защита может применяться, например, в Апплетах (Applets);
    Получение доступа к внутренностям класса, что нарушает принцип инкапсуляции. Фактически, мы получаем доступ туда, куда обычному человеку лезть не желательно. Это как с розеткой, ребёнку лучше к ней не лезть, тогда как опытный электрик запросто с ней поладит.
    В Java есть специальный класс по имени Class. С помощью него осуществляется работа с рефлексией, он и является входной точкой.
    Class есть у:
    классов, интерфейсов, перечислений;
    примитивов и обёрток над ними;
    массивов;
    void. Ключевое слово void также имеет Class.
## 2. Где и зачем используют?
    Рефлексия — мощная концепция, которая лежит в основе большинства современных Java/Java EE фреймворков и библиотек. Например, для Java классическими примерами являются:
    JUnit – фреймворк для модульного тестирования. Он использует рефлексию для парсинга аннотаций (например, @Test) для получения описанных программистом тестовых методов и дальнейшего их выполнения.
    Spring – фреймворк для разработки приложений на Java платформе, в основе которого лежит внедрение зависимостей (инверсия управления).
    Список можно продолжать: от веб-контейнеров до решения задач объектно-реляционного отображения (ORM). Их объединяет одно: они используют Java рефлексию, потому что не имеют доступа и представления к определенных пользователем классах, методах, интерфейсах и т.д.
## 3. Недостатки рефлексии
    Низкая производительность — поскольку рефлексия в Java определяет типы динамически, то она сканирует classpath, чтобы найти класс для загрузки, в результате чего снижается производительность программы.
    Ограничения системы безопасности — рефлексия требует разрешения времени выполнения, которые не могут быть доступны для систем, работающих под управлением менеджера безопасности (Java Security Manager).
    Нарушения безопасности приложения — с помощью рефлексии мы можем получить доступ к части кода, к которой мы не должны получать доступ. Например, мы можем получить доступ к закрытым полям класса и менять их значения. Это может быть серьезной угрозой безопасности.
    Сложность в поддержке — код, написанный с помощью рефлексии трудно читать и отлаживать, что делает его менее гибким и трудно поддерживаемым.
##  RMI
## 1. Что такое RMI?
    RMI (англ. Remote Method Invocation) — программный интерфейс вызова удаленных методов в языке Java.
    Распределенная объектная модель, специфицирующая, каким образом производится вызов удаленных методов, работающих на другой виртуальной машине Java.
    При доступе к объекту на другом компьютере возможно вызывать методы этого объекта. Необходимо только передать параметры метода на другой компьютер, сообщить объекту о необходимости выполнения метода, а затем получить обратно возвращаемое значение. Механизм RMI даёт возможность организовать выполнение всех этих операций.
    Типичная реализация модели Java-RMI, использующая объекты 'заглушки'(stub) и 'скелета'(skeleton).
    В терминах RMI объект, который вызывает удаленный метод, называется клиентским объектом, а удаленный объект — серверным объектом. Компьютеры выступают в роли клиента и сервера только для конкретного вызова. Вполне возможно, что при выполнении следующей операции эти компьютеры поменяются ролями, то есть сервер предыдущего вызова может сам стать клиентом при обращении к объекту на другом компьютере.
    При вызове метода удаленного объекта на самом деле вызывается обычный метод языка Java, инкапсулированный в специальном объекте-заглушке (stub), который является представителем серверного объекта. Заглушка находится на клиентском компьютере, а не на сервере. Она упаковывает параметры удаленного метода в блок байтов. Каждый параметр кодируется с помощью алгоритма, обеспечивающего независимость от аппаратуры. Например, числа всегда передаются в порядке, при котором сначала передается старший байт (big-endian). При этом объекты подвергаются сериализации. Процесс кодирования параметров называется развертыванием параметров (parameter marshaling). Основная цель развертывания параметров — преобразование их в формат, пригодный для передачи параметров от одной виртуальной машины к другой.

Метод, принадлежащий заглушке, создаёт блок, в который входят следующие элементы:
идентификатор удаленного объекта;
описание вызываемого метода;
развернутые параметры.
Затем метод заглушки посылает эту информацию серверу. Далее объект-получатель, скелет (skeleton), выполняет для каждого вызова удаленного метода следующие действия:
свёртывание параметров;
поиск вызванного объекта;
вызов заданного метода;
извлечение и развёртывание возвращаемого значения или исключения, сгенерированного данным методом;
передача пакета, состоящего из развернутых возвращаемых данных, объекту-заглушке на клиентском компьютере.
Клиентский объект-заглушка свертывает возвращаемое значение или исключение, полученное с сервера. Результат свертывания становится возвращаемым значением метода заглушки. Если удаленный метод возвращает исключение, то объект-заглушка повторит его в среде объекта-клиента.
Конечно, интерфейсы представляют собой абстракции и содержат только перечень методов. Переменные типа interface всегда должны быть связаны с фактическим объектом. При вызове удаленных объектов переменная ссылается на объект-заглушку. При этом клиентская программа ничего не знает о типе заглушки, а сами заглушки и связанные с ними объекты создаются автоматически.
При передаче объекта другой программе (он может быть параметром либо возвращаемым значением удаленного метода) нужен файл класса, соответствующий этому объекту. Например, метод, который возвращает значение типа Product. При компиляции клиентской программы должен быть сгенерирован файл класса Product.class.
При загрузке фрагментов кода по сети всегда возникают сомнения по поводу должного обеспечения безопасности. В связи с этим в приложениях с использованием RMI применяется диспетчер защиты. Он защищает заглушки от проникновения в них вирусов.
## 2. Принцип архитектуры RMI. Разные слои.
В приложении RMI пишем две программы: серверную (на сервере) и клиентскую (на клиенте).
Внутри серверной программы создается удаленный объект, и ссылка на этот объект становится доступной для клиента (с использованием реестра).
Клиентская программа запрашивает удаленные объекты на сервере и пытается вызвать его методы.
Компоненты архитектуры.
Транспортный уровень — этот уровень связывает клиента и сервер. Он управляет существующим соединением, а также устанавливает новые соединения.
Заглушка — это представление (прокси) удаленного объекта на клиенте. Он находится в клиентской системе; он действует как шлюз для клиентской программы.
Скелет — это объект, который находится на стороне сервера. заглушка связывается с этим скелетом для передачи запроса удаленному объекту.
RRL (Remote Reference Layer) — это уровень, который управляет ссылками, сделанными клиентом на удаленный объект.
Реестр RMI
Реестр RMI — это пространство имен, в котором размещены все объекты сервера. Каждый раз, когда сервер создает объект, он регистрирует этот объект в RMIregistry (используя методы bind() или reBind() ). Они зарегистрированы с использованием уникального имени, известного как имя привязки.
Цели РМИ
Чтобы минимизировать сложность приложения.
Чтобы сохранить безопасность типов.
Распределенная сборка мусора.
Минимизируйте разницу между работой с локальными и удаленными объектами.
## 3. Удаленный интерфейс
Удаленный интерфейс предоставляет описание всех методов конкретного удаленного объекта. Клиент связывается с этим удаленным интерфейсом.
Чтобы создать удаленный интерфейс:
Создайте интерфейс, который расширяет предопределенный интерфейс Remote, который принадлежит пакету.
Объявите все бизнес-методы, которые могут быть вызваны клиентом в этом интерфейсе.
Обработать RemoteException.
## 4 Удаленный объект
Нужно реализовать удаленный интерфейс.
Разработать класс реализации —
Реализовать удаленный интерфейс.
Обеспечить реализацию всех абстрактных методов удаленного интерфейса.
