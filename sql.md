## SQL
## 1.General Questions on SQL SERVER
## 1.1. What is RDBMS?
Реляционная система управления базами данных (RDBMS) - это программная система, обеспечивающая доступ к реляционной базе данных.
Программная система представляет собой набор программных приложений, которые могут использоваться для создания, обслуживания, управления и использования базы данных. «Реляционная база данных» - это база данных, структурированная по «реляционной» модели. Данные хранятся и представлены в табличном формате, организованном в строках и столбцах с одной записью в строке.
RDBMS позволяет создавать, обновлять и администрировать реляционную базу данных. Большинство систем управления реляционными базами данных используют SQL для доступа к базе данных. Реляционные базы данных часто заменяют устаревшие иерархические и сетевые БД, так как они проще в использовании.
## 1.2. What are the Properties of the Relational Tables?
Каждая реляционная таблица представляет собой двумерный массив и обла­дает следующими свойствами:
каждый элемент таблицы — один элемент данных;
все столбцы в таблице однородные, т.е. все элементы в столбце имеют одинаковый тип и длину;
каждый столбец имеет уникальное имя;
одинаковые строки в таблице отсутствуют;
порядок следования строк и столбцов может быть произвольным.
Отношения представлены в виде таблиц, строки которых соответствуют кортежам или записям, а столбцы — атрибутам отношений, доменам, полям.
## 1.3. What is Normalization?
Нормализация – это процесс удаления избыточных данных.
Нормализация – это метод проектирования базы данных, который позволяет привести базу данных к минимальной избыточности.
Нормализация используется для минимизации избыточности отношения или набора отношений. Он также используется для устранения нежелательных характеристик, таких как аномалии вставки, обновления и удаления.
Нормализация делит большую таблицу на меньшую и связывает их с помощью отношения.
Обычная форма используется для уменьшения избыточности таблицы базы данных.
Избыточность данных создает предпосылки для появления различных аномалий, снижает производительность, и делает управление данными не гибким и не очень удобным.
Нормализация нужна для:
Устранения аномалий
Повышения производительности
Повышения удобства управления данными
Избыточность данных – это когда одни и те же данные хранятся в базе в нескольких местах, именно это и приводит к аномалиям.
Нормальная форма базы данных – это набор правил и критериев, которым должна отвечать база данных.
## 1.4. What are different types of Normalization Levels or Normalization Forms? What is De-normalization?
Процесс нормализации – это последовательный процесс приведения базы данных к эталонному виду, т.е. переход от одной нормальной формы к следующей.
Существует 5 основных нормальных форм базы данных:
1.     Первая нормальная форма (1NF) (1)
o   В таблице не должно быть дублирующих строк
o  В каждой ячейке таблицы хранится атомарное значение (одно не составное значение)
o   В столбце хранятся данные одного типа
o   Отсутствуют массивы и списки в любом виде
2.     Вторая нормальная форма (2NF) (2)
o   Таблица должна находиться в первой нормальной форме
o   Таблица должна иметь ключ
o   Все неключевые столбцы таблицы должны зависеть от полного ключа (в случае если он составной)
Правило - Таблица должна иметь правильный ключ, по которому можно идентифицировать каждую строку.
3.     Третья нормальная форма (3NF) (3) (!)
4.     Четвертая нормальная форма (4NF) (5)
5.     Пятая нормальная форма (5NF) (6)
Однако выделяют еще дополнительные нормальные формы:
Ненормализованная форма или нулевая нормальная форма (UNF) (1)
Нормальная форма Бойса-Кодда (BCNF) (4)
Доменно-ключевая нормальная форма (DKNF) (7)
Шестая нормальная форма (6NF) (8)
Денормализация — намеренное приведение структуры базы данных в состояние, не соответствующее критериям нормализации, обычно проводимое с целью ускорения операций чтения из базы за счет добавления избыточных данных.
денормализация путем сокращения количества таблиц.
денормализация путем ввода дополнительного поля в одну из таблиц.
Декомпозиция – это процесс разбиения одного отношения (таблицы) на несколько.
## 1.5. What is a transaction and what are ACID properties? Explain different isolation levels
Транза́кция — группа последовательных операций с базой данных, которая представляет собой логическую единицу работы с данными. Транзакция может быть выполнена либо целиком и успешно, соблюдая целостность данных и независимо от параллельно идущих других транзакций, либо не выполнена вообще, и тогда она не должна произвести никакого эффекта. Транзакции обрабатываются транзакционными системами, в процессе работы которых создаётся история транзакций.
Различают последовательные (обычные), параллельные и распределённые транзакции. Распределённые транзакции подразумевают использование более чем одной транзакционной системы и требуют намного более сложной логики (например, two-phase commit — двухфазный протокол фиксации транзакции). Также в некоторых системах реализованы автономные транзакции, или под-транзакции, которые являются автономной частью родительской транзакции.
Акроним ACID описывает требования к транзакционной системе (например, к СУБД), обеспечивающие наиболее надёжную и предсказуемую её работу.
Требования ACID:
1. Atomicity — Атомарность
2. Consistency — Согласованность
3. Isolation — Изолированность
4. Durability — Прочность
   Видов несогласованности данных:
   потерянное обновление (lost update) — при одновременном изменении одного блока данных разными транзакциями теряются все изменения, кроме последнего;
   «грязное» чтение (dirty read) — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится);
   неповторяющееся чтение (non-repeatable read) — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;
   фантомное чтение (phantom reads) — одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет строки или изменяет столбцы некоторых строк, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества строк.
   Уровни изоляции
1. Read uncommitted (чтение незафиксированных данных)
2. Read committed (чтение фиксированных данных)
3. Блокирование читаемых и изменяемых данных.
4. Сохранение нескольких версий параллельно изменяемых строк.
5. Repeatable read (повторяющееся чтение)
6. Serializable (упорядочиваемость)
##    1.6. Which Database feature assist in ACID capabilities
2. Joins (inner, outer…)
   2.1. What is join? Different types of SQL join clauses and how are they used.
   Операция соединения, как и другие бинарные операции, предназначена для обеспечения выборки данных из двух таблиц и включения этих данных в один результирующий набор. Отличительными особенностями операции соединения являются следующие:
   в схему таблицы-результата входят столбцы обеих исходных таблиц
   каждая строка таблицы-результата является «сцеплением» строки из одной таблицы-операнда со строкой второй таблицы-операнда.
   Виды оператора JOIN:
1.     INNER JOIN. Оператор внутреннего соединения соединяет две таблицы (порядок таблиц для оператора неважен).
2.     OUTER JOIN. Соединение двух таблиц, в результат которого обязательно входят все строки либо одной, либо обеих таблиц.
3.     LEFT OUTER JOIN. Оператор левого внешнего соединения соединяет две таблицы (порядок таблиц для оператора важен).
4.     RIGHT OUTER JOIN. Оператор правого внешнего соединения соединяет две таблицы (порядок таблиц для оператора важен).
5.     FULL OUTER JOIN. Оператор полного внешнего соединения соединяет две таблицы. (порядок таблиц для оператора неважен).
6.     CROSS JOIN. Оператор перекрёстного соединения, или декартова произведения соединяет две таблицы. (порядок таблиц для оператора неважен).
## 2.2. Differences between joins.
CROSS JOIN: операция объединяет каждую строку первой таблицы с каждой строкой второй таблицы.
INNER JOIN: возвращает строки, когда есть совпадение в обеих таблицах.
OUTER JOIN: возвращает строки одной таблицы, для которых не были найдены соответствующие строки в другой таблице
LEFT JOIN: возвращает все строки из левой таблицы, даже если в правой таблице нет совпадений.
RIGHT JOIN: возвращает все строки из правой таблицы, даже если в левой таблице нет совпадений.
FULL JOIN: Он объединяет результаты как левого, так и правого внешних соединений. Объединенная таблица будет содержать все записи из обеих таблиц и заполнять NULL для отсутствия совпадений с обеих сторон.
## 2.3. Full outer join. How to use.

## 2.4. Non-Equal Join.
Неэквивалентные соединения - это соединения, в условиях которых используются условные операторы, отличные от равенства.
При объединении таблиц не используется оператор равенства (=), а какой-либо другой оператор (<> или! =,>,> =, <, <=, BETWEEN… AND).
## 2.5. Self join. When and how to use.
Присоединяет таблицу к самой себе. Чтобы использовать самосоединение, таблица должна содержать столбец (IDX), который действует как первичный ключ, и другой столбец (IDY), в котором хранятся значения, которые могут быть сопоставлены со значениями в столбце IDX. Значения Столбцов IDX и IDY не обязательно должны быть одинаковыми для любой данной строки, а значение в столбце IDY может даже быть нулевым.


2.6. Nested join.
2.7. Cartesian join.
CARTESIAN JOIN (CROSS JOIN) каждая строка одной таблицы соединяется с каждой строкой другой таблицы. Обычно это происходит, когда соответствующий столбец или условие WHERE не указаны.
При отсутствии условия WHERE CARTESIAN JOIN будет вести себя как CARTESIAN PRODUCT, то есть количество строк в наборе результатов является произведением количества строк в двух таблицах. При наличии условия WHERE это JOIN будет работать как INNER JOIN.

## 3. Keys (Primary, unique, foreign)
   3.1. What is a primary key? Restrictions, best practice.
   Primary Key - комбинация NOT NULL и UNIQUE. Уникально идентифицирует каждую строку в таблице
   Перви́чный ключ (primary key) — в реляционной модели данных один из потенциальных ключей отношения, выбранный в качестве основного ключа (или ключа по умолчанию).
   Если в отношении имеется единственный потенциальный ключ, он является и первичным ключом. Если потенциальных ключей несколько, один из них выбирается в качестве первичного, а другие называют «альтернативными».
   Ограничения:
   быть уникальным все время
   постоянно присутствовать в таблице и иметь значение
   не должен часто менять свое значение. В идеале он вообще не изменяет значение.
   Дополнительно:
   Ограничение первичного ключа однозначно идентифицирует каждую запись в таблице базы данных.
   Первичные ключи должны содержать уникальные значения и не могут содержать значения NULL.
   Таблица может иметь только один первичный ключ, который может состоять из одного или нескольких полей.
 ##   3.2. What is an unique key? Restrictions, best practice.
   Уникальный ключ - это набор из одного или нескольких полей / столбцов таблицы, которые однозначно идентифицируют запись в таблице базы данных. UNIQUE - гарантирует, что все значения в столбце разные.
   Ограничение UNIQUE гарантирует, что все значения в столбце отличаются.
   Ограничения UNIQUE и PRIMARY KEY гарантируют уникальность столбца или набора столбцов. Ограничение PRIMARY KEY автоматически имеет ограничение UNIQUE.
   Для каждой таблицы может быть множество ограничений UNIQUE, но только одно ограничение PRIMARY KEY для каждой таблицы.
   Ограничения UNIQUE допускают значение NULL
 ##  3.3. What is foreign key? Restrictions, best practice.
   FOREIGN KEY - уникально идентифицирует строку / запись в другой таблице.
   Внешний (вторичный) ключ - это одно или несколько полей (столбцов) в таблице, содержащих ссылку на поле или поля первичного ключа в другой таблице. Внешний ключ определяет способ объединения таблиц.
   Значение внешнего ключа должно соответствовать существующему значению в родительской таблице или быть NULL.
   Внешние ключи основаны на значениях данных и являются лишь логическими, а не физическими, указателями.
 ##  3.4. Primary vs unique key.
   Primary Key
   Unique Key
   Уникальный идентификатор строк таблицы
   Уникальный идентификатор для строк таблицы при отсутствии первичного ключа
   Не может быть NULL
   Может быть NULL
   В таблице может присутствовать только один первичный ключ
   В таблице может присутствовать несколько уникальных ключей
   присутствует в таблице
   присутствует в таблице
   Выбор с использованием первичного ключа создает кластерный индекс
   Выбор с использованием уникального ключа создает некластеризованный индекс

## 3.5. Foreign vs primary key.
PRIMARY KEY
FOREIGN KEY

Первичный ключ используется для обеспечения уникальности данных в конкретном столбце.
Внешний ключ - это столбец или группа столбцов в таблице реляционной базы данных, которая
обеспечивает связь между данными в двух таблицах.
Он однозначно определяет запись в таблице реляционной базы данных.
Он относится к полю в таблице, которое является первичным ключом другой таблицы.
В таблице разрешен только один первичный ключ.
В то время как в таблице допускается более одного внешнего ключа.
Это комбинация ограничений UNIQUE и Not Null.
Он может содержать повторяющиеся значения и таблицу в реляционной базе данных.
Он не допускает значений NULL.
Он также может содержать значения NULL.
Его значение нельзя удалить из родительской таблицы.
Его значение можно удалить из дочерней таблицы.
Это ограничение может быть неявно определено во временных таблицах.
Это ограничение не может быть определено для локальных или глобальных временных таблиц.

## 4. Views
 ##  4.1. What is View?
   Представление (VIEW)( «виртуальными таблицами») - объект данных который не содержит никаких данных его владельца. Это - тип таблицы, чье содержание выбирается из других таблиц с помощью выполнения запроса. Поскольку значения в этих таблицах меняются, то автоматически, их значения могут быть показаны представлением.
   Представление (view, иногда используются названия «вид», «взгляд», «проекция») — виртуальная (логическая) таблица, представляющая собой поименованный запрос (синоним к запросу), который будет подставлен как подзапрос при использовании представления.
 ##  4.2. Advantages and disadvantages of using Views.
   Преимущества
   Безопасность
   Простота запросов
   Простота структуры
   Защита от изменений
   Целостность данных
   Недостатки
   уменьшение производительности
   Ограничения на обновление
##   4.3. Materialized views.
   Материализо́ванное представле́ние — физический объект базы данных, содержащий результат выполнения запроса.
   Материализованные представления позволяют многократно ускорить выполнение запросов, обращающихся к большому количеству (сотням тысяч или миллионам) записей, позволяя за секунды (и даже доли секунд) выполнять запросы к терабайтам данных. Это достигается за счет прозрачного использования заранее вычисленных итоговых данных и результатов соединений таблиц. Предварительно вычисленные итоговые данные обычно имеют очень небольшой объем по сравнению с исходными данными.
 ##  4.4. Limitations of a view.
   нельзя повесить триггер на представление,
   нельзя сделать представление на основе временных таблиц; нельзя сделать временное представление;
   в определении представления нельзя использовать подзапрос в части FROM,
   в определении представления нельзя использовать системные и пользовательские переменные; внутри хранимых процедур нельзя в определении представления использовать локальные переменные или параметры процедуры,
   в определении представления нельзя использовать параметры подготовленных выражений (PREPARE),
   таблицы и представления, присутствующие в определении представления должны существовать.
   только представления, удовлетворяющие ряду требований, допускают запросы типа UPDATE, DELETE и INSERT.
## 5.  Indexes
## 5.1. What is an index? When and how to create.
    Индекс (англ. index) — объект базы данных, создаваемый с целью повышения производительности поиска данных.
    Таблицы в базе данных могут иметь большое количество строк, которые хранятся в произвольном порядке, и их поиск по заданному критерию путём последовательного просмотра таблицы строка за строкой может занимать много времени. Индекс формируется из значений одного или нескольких столбцов таблицы и указателей на соответствующие строки таблицы и, таким образом, позволяет искать строки, удовлетворяющие критерию поиска. Ускорение работы с использованием индексов достигается в первую очередь за счёт того, что индекс имеет структуру, оптимизированную под поиск — например, сбалансированного дерева.
## 5.2. Advantages and disadvantages of using indexes.
    Достоинства:
    увеличение скорости доступа к данным
    поддержка уникальности данных
    Недостатки:
    индексы занимают дополнительное место на диске и в оперативной памяти
    замедляются операции вставки, обновления и удаления записей
##  5.3. Types of indexes (Oracle).
    Normal index
    Unique Index
    Bit Map Index
    Composite Index
    B-Tree Index(Oracle considered Normal indexes as B-Tree Indexes)
    Function Based Index
    Clustered Index
    Non-Clustered Index.
    Простой индекс (simple index, single-column index) — индекс, построенный на одном поле таблицы. Упрощенно: индекс, включающий информацию о содержимом только одного поля таблицы.
    Составной индекс (composite index) — индекс, построенный на двух и более полях таблицы. Упрощенно: индекс, включающий информацию о содержимом двух и более полей таблицы.
    Уникальный индекс (unique index) — индекс, построенный на содержащем уникальные значения поле (полях) таблицы. Упрощенно: индекс, построенный на поле, являющемся первичным или альтернативным ключом таблицы.
    Неуникальный индекс (non-unique index, index) — индекс, построенный на не содержащем уникальные значения поле (полях) таблицы. Упрощенно: «просто индекс» (для неуникального индекса в синтаксисе SQL даже нет отдельного ключевого слова, просто пишется INDEX).
    Кластерный индекс (clustered index) — индекс, построенный на поле (возможно, с неуникальными значениями), по которому произведено физическое упорядочивание данных в файле. Упрощенно: по значению индексированного поля данные таблицы физически отсортированы на диске; значения поля могут повторяться.
    Первичный индекс (primary index) — индекс, построенный на поле с уникальными значениями, по которому произведено физическое упорядочивание данных в файле. Упрощенно: по значению индексированного поля данные таблицы физически отсортированы на диске; значения поля не могут повторяться.
    Некластерный индекс (non-clustered index) — индекс, построенный на поле, по которому не произведено физическое упорядочивание данных в файле. Упрощенно: «просто индекс», принципы упорядочивания в котором никак не связаны с физическим расположением данных на диске.
## 5.4. Best practice of creating and using indexes.
    операции чтения из таблицы выполняются гораздо чаще, чем операции модификации;
    поле или совокупность полей часто фигурируют в запросах в секции WHERE;
    исследование показало, что наличие индекса повышает производительность запросов;
    необходимо обеспечить уникальность значения поля (или совокупности полей), не являющегося первичным ключом (в таком случае строится т.н. уникальный индекс{109});
    поле (или совокупность полей) является внешним ключом — в таком случае индексы могут значительно ускорить выполнение JOIN-запросов.
    Создание индексов на основе использования.
    Индекс поиска (WHERE) столбцы.
    Сортировка индекса (ORDER BY) столбцы.
    Группировка индекса и агрегированные столбцы
    Индекс по всем Foreign ключам
    Индекс Unique столбец (Primary key)
    Используйте кластерный индекс для больших таблиц
    Удалить неиспользуемые индексы
## GROUP BY, Having...
## 6.1. Grouping data using Group by.
   GROUP BY – это оператор (или конструкция, кому как удобней) SQL для группировки данных по полю, при использовании в запросе агрегатных функций, таких как sum, max, min, count и других.
## 6.2. Group by vs Distinct.
   Distinct используется для поиска уникальных / отличных записей
   Group by используется для группировки выбранного набора строк в итоговые строки по одному или нескольким столбцам или выражению.
## 6.3. Aggregation functions and group by.
   Агрегатные функции - это функции, которые вычисляют значение из одной или нескольких строк в зависимости от столбца, для которого выполняется функция. Эти функции включают COUNT, SUM, AVG, MAX и MIN. Они игнорируют значения NULL.
   Function Name
   Meaning
   Example
   SUM(column name)
   Сумма значений в числовом столбце
   SUM(SALARY)
   AVG(column name)
   Среднее значение в столбце
   AVG(SALARY)
   MAX(column name)
   Наибольшее значение в столбце
   MAX(SALARY)
   MIN(column name)
   Наименьшее значение в столбце
   MIN(SALARY)
   COUNT(*)
   Подсчет количества выбранных строк
   COUNT(*)

## 6.4. Filtering data with Having clause.
HAVING — необязательный (опциональный) параметр оператора SELECT для указания условия на результат агрегатных функций (MAX, SUM, AVG, …).
HAVING <условия> аналогичен WHERE <условия> за исключением того, что строки отбираются не по значениям столбцов, а строятся из значений столбцов, указанных в GROUP BY, и значений агрегатных функций, вычисленных для каждой группы, образованной GROUP BY.
Необходимо, чтобы в SELECT были заданы только требуемые в выходном потоке столбцы, перечисленные в GROUP BY и/или агрегированные значения.
Если параметр GROUP BY в SELECT не задан, HAVING применяется к «группе» всех строк таблицы, полностью дублируя WHERE (допускается не во всех реализациях стандарта SQL).
SELECT DeptID, SUM(SaleAmount) FROM Sales   WHERE SaleDate = '01-Jan-2000'  GROUP BY DeptID  HAVING SUM(SaleAmount) > 1000
## 6.5. Difference between group by and having.
Having Clause
GroupBy Clause
Он используется для применения к запросу некоторого дополнительного условия.
используется для группировки данных по определенному столбцу или строке
Having не может использоваться без предложения groupby
можно использовать без предложения с оператором select
having может содержать агрегатные функции
Он не может содержать агрегатных функций
Он ограничивает вывод запроса с помощью некоторых условий
Он группирует вывод на основе нескольких строк или столбцов

6.6. Best practice of using group by and having.
## 7. Delete, Truncate, Drop
## 7.1. Delete operation details.
   DELETE — в языках, подобных MDl, SQL-операция удаления записей из таблицы. Критерий отбора записей для удаления определяется выражением where. В случае, если критерий отбора не определён, выполняется удаление всех записей.
   В СУБД, поддерживающих триггеры, операция Delete может вызывать их срабатывание;
   При наличии на таблице внешних ключей все дочерние к удаляемым записи в подчинённых таблицах также должны быть удалены для обеспечения ссылочной целостности;
   В СУБД, поддерживающих транзакции, выполнение операции Delete должно быть подтверждено (COMMIT), либо опровергнуто (ROLLBACK) вызовом соответствующих операций.
 ##  7.2. Truncate operation details.
   TRUNCATE — в языке SQL — операция мгновенного удаления всех строк в таблице. Логически схожа с операцией DELETE без оператора WHERE
   не журнализируется удаление отдельных строк таблицы; в журнал записывается только освобождение страниц, которые были заняты данными таблицы;
   не отрабатывают триггеры, в частности, триггер на удаление;
   команда неприменима, если на данную таблицу имеется ссылка по внешнему ключу, и даже если внешний ключ имеет опцию каскадного удаления.
   значение счетчика (IDENTITY) сбрасывается в начальное значение.
  ## 7.3. Drop sql command.
   DROP используется для удаления всей базы данных или только таблицы. Оператор DROP уничтожает такие объекты, как существующая база данных, таблица, индекс или представление.
   Оператор DROP в SQL удаляет компонент из системы управления реляционными базами данных (RDBMS).
   DROP TABLE table_name;
   Truncate обычно сверхбыстрый и идеально подходит для удаления данных из временной таблицы.
   Truncate сохраняет структуру таблицы для будущего использования, в отличие от drop table, где таблица удаляется с ее полной структурой.
   Удаление таблицы или базы данных с помощью оператора DROP не может быть отменено
  ## 7.4. Delete vs truncate. Best practice.
   Операция TRUNCATE не записывает в журнал событий удаление отдельных строк. Вследствие чего не может активировать триггеры.
   После операции TRUNCATE для некоторых СУБД (например, Oracle) следует неявная операция COMMIT. Поэтому удаленные в таблице записи нельзя восстановить операцией ROLLBACK. Но существуют и СУБД, в которых операция TRUNCATE может участвовать в транзакциях, например, PostgreSQL и Microsoft SQL Server.
   Операция DELETE блокирует каждую строку, а TRUNCATE — всю таблицу.
   Операция TRUNCATE не возвращает какого-то осмысленного значения (обычно возвращает 0) в отличие от DELETE, которая возвращает число удаленных строк.
   Операция TRUNCATE в некоторых СУБД (например, MySQL или Microsoft SQL Server), сбрасывает значение счетчиков (для полей с AUTOINCREMENT / IDENTITY). В PostgreSQL для сброса счётчиков необходимо указывать модификатор RESTART IDENTITY.
   Операция TRUNCATE в некоторых СУБД (например, MySQL, PostgreSQL или Microsoft SQL Server) запрещена для таблиц, содержащих внешние ключи других таблиц. В PostgreSQL существует, однако, модификатор CASCADE, который разрешает TRUNCATE в этой ситуации – данные из зависимых таблиц удаляются в той же транзакции.
   В SQLite операция как таковая отсутствует, но есть оптимизация операции DELETE, которая «значительно ускоряет её работу, если отсутствует аргумент WHERE».
   DELETE
   TRUNCATE TABLE
   DELETE – это оператор DML (Data Manipulation Language)
   TRUNCATE TABLE – это оператор DDL (Data Definition Language);
   DELETE может удалить часть данных за счет использования WHERE
   TRUNCATE TABLE удаляет все данные из таблицы, секцию WHERE использовать нельзя
   DELETE записывает в журнал транзакций удаление каждой строки
   TRUNCATE TABLE удаляет все строки в таблице, не записывая при этом удаление отдельных строк данных в журнал транзакций
   Для DELETE требуется больший объем журнала транзакций
   Для TRUNCATE TABLE требуется меньший объем журнала транзакций, за счет того, что она не заносит в журнал запись для каждой удаляемой строки
   DELETE выполняется медленнее
   TRUNCATE TABLE выполняется быстрее также за счет меньшего использования журнала транзакций
   DELETE удаляет строки по одной за раз
   TRUNCATE TABLE удаляет все строки в таблице путем освобождения страниц
   DELETE создает блокировку на каждую строку, которую требуется удалить из таблицы
   TRUNCATE TABLE блокирует в целом таблицу и страницу, чтобы удалить все записи
   DELETE сохраняет счетчик идентификаторов и не сбрасывает его до начального значения
   TRUNCATE TABLE сбрасывает счетчик идентификаторов до начального значения
   DELETE может активировать триггер
   TRUNCATE TABLE не может активировать триггер, поскольку в данном случае в журнал не записываются удаление отдельных строк
   DELETE сохраняет статистику объекта и выделенное пространство
   TRUNCATE TABLE освобождает все страницы данных таблицы, поэтому TRUNCATE удаляет всю статистику и выделенное пространство
   DELETE можно использовать, если таблица является частью индексированного представления
   TRUNCATE TABLE нельзя использовать, если таблица является частью индексированного представления
   Чтобы использовать DELETE, необходимы соответствующие права на удаление данных
   Чтобы использовать TRUNCATE TABLE, у Вас должны быть права на ALTER TABLE, т.е. на изменение таблицы

7.5. Deleting duplicate rows when there is no primary key on a database table.
1. Удаление дубликатов используя обобщенные табличные выражения (CTE)
   Можно использовать связку обобщенных табличных выражений и функции ROW_number() для удаления дубликатов, используя функцию ROW_number() с конструкцией partition BY в предложении OVER для нумерации записей, и удаляем записи с пронумерованными значениями > 1, соответствующие дубликатам.
   WITH CTE ([Фамилия], [Имя]) AS (SELECT [Фамилия], [Имя] ROW_NUMBER () OVER (PARTITION BY [Фамилия], [Имя]
   ORDER BY id) AS [Нумерация] FROM NTA.dbo.Employee)
   DELETE FROM CTE WHERE [Нумерация] > 1
2. Удаление дубликатов с использованием инструментария SSIS пакетов.
8. A database trigger(Oracle)
   Триггер – это именованный pl/sql блок, который хранится в базе данных, выполняемый в ответ на происходящие в базе данных Oracle события.

Нельзя самому вызвать триггер, он всегда срабатывает только на определенное событие автоматически(если он enable)
Не стоит создавать рекурсивные триггера. Т.е., например, триггер after update, в котором выполняется update той же таблицы. В этом случае триггер будет срабатывать рекурсивно до тех пор, пока не закончится память.
Используются для выполнения следующих действий:
Проверка вносимых в таблицы изменений.
Автоматизация сопровождения базы данных.
Точная настройка ограничений на выполнение административных операций.
Существуют пять видов событий, с которыми можно связывать триггеры:
Команды DML (Data Manipulation Language). Триггеры DML запускаются в ответ на вставку, обновление и удаление строки таблицы базы данных. Их можно исполь­зовать с целью проверки значений, устанавливаемых по умолчанию, выполнения аудита изменений и даже запрета определенных команд DML.
Команды DDL (Data Definition Language). Триггеры DDL запускаются в ответ на выполнение команд DDL — например, при создании таблицы. С их помощью можно выполнять аудит и запрещать определенные операции.
События базы данных. Триггеры событий базы данных используются при запуске и остановке базы данных, при подключении и отключении сервера, а также при возникновении ошибок Oracle. Начиная с Oracle8i они также позволяют получать информацию об операциях с базой данных.
Триггеры INSTEAD OF. Замещающие триггеры являются альтернативой триггерам DML. Они запускаются непосредственно перед операци­ями вставки, обновления, удаления, и их код определяет, какие действия следует выполнить вместо соответствующей операции DML. Триггеры INSTEAD OF управля­ют операциями над представлениями, но не над таблицами. С их помощью можно преобразовывать необновляемые представления в обновляемые, изменяя при не­обходимости их поведение.
Приостановленные команды. В Oracle9i введена концепция приостановленных команд. Если в ходе выполнения команды возникла проблема доступности простран­ства (недостаточно табличного пространства или исчерпана квота), Oracle может перевести ее в режим приостановления до тех пор, пока проблема не будет решена. С данным событием можно связать триггер, который автоматически уведомляет пользователя о проблеме или даже самостоятельно устраняет ее.
8.1. Different Types of triggers.
DML trigger (на таблицу или представление)
System trigger (на схему или базу данных)
Conditional trigger (те, которые имеют условие when)
Instead of trigger (dml триггер на представление или system триггер на команду create)
Триггеры могут быть классифицированы на основе следующих параметров.
Классификация на основе term (сроков)
BEFOR триггер: срабатывает до наступления указанного события.
AFTER триггер: срабатывает после наступления указанного события.
INSTEAD триггер: особый тип.
Классификация на основе level(уровня)
Триггер уровня STATEMENT: запускается один раз для указанного оператора события.
Триггер уровня ROW: срабатывает для каждой записи, которая была затронута в указанном событии. (только для DML)
Классификация на основе event(события)
Триггер DML: срабатывает, когда указано событие DML (INSERT / UPDATE / DELETE)
DDL Trigger: срабатывает, когда указано событие DDL (CREATE / ALTER)
Триггер базы данных: срабатывает, когда задано событие базы данных (LOGON / LOGOFF / STARTUP / SHUTDOWN
8.2. Row vs statement triggers.
Row Level Triggers
Statement Level Triggers
выполняются один раз для каждой строки транзакции.
выполняются только один раз для каждой отдельной транзакции.
Специально используется для аудита данных
Используется для обеспечения всей дополнительной безопасности транзакций, выполняемых в таблице.
FOR EACH ROW присутствует в команде CREATE TRIGGER.
FOR EACH ROW опущено в команде CREATE TRIGGER.
если в таблицу нужно вставить 1500 строк, триггер уровня строки будет выполнен 1500 раз.
если в таблицу нужно вставить 1500 строк, триггер уровня оператора будет выполняться только один раз.

8.3. Before vs After vs Instead of triggers.
Функция
Триггер AFTER
Триггер INSTEAD OF
Сущности, к которым применяется триггер
Таблицы.
Таблицы и представления.
Количество триггеров на таблицу или представление
Несколько триггеров на одно запускающее триггеры действие (UPDATE, DELETE или INSERT).
Один триггер на одно запускающее триггеры действие (UPDATE, DELETE или INSERT).
Каскадные ссылки
Нет ограничений.
Триггеры INSTEAD OF UPDATE и DELETE нельзя определять для таблиц, на которые распространяются каскадные ограничения ссылочной целостности.
Выполнение
После следующих операций.с
– Обработка ограничений.
– Декларативные ссылочные действия.
– Создание таблиц inserted и deleted.
– Действие, запускающее триггер.
Перед следующей операцией.
– Обработка ограничений.
– Вместо следующей операции.
– Действие, запускающее триггер.
– После следующих операций.
– Создание таблиц inserted и deleted.
Порядок выполнения
Можно задать выполнение в первую и в последнюю очередь.
Неприменимо
Ссылки на столбцы varchar(max), nvarchar(max) и varbinary(max) в таблицах inserted и deleted
Разрешены.
Разрешены.
Ссылки на столбцы text, ntext и image в таблицах inserted и deleted
Запрещены.
Разрешены.

8.4. System vs User events.
8.5. Best practice of using triggers.
Использование триггеров:
Для автоматической генерации значений виртуального поля
Для логирования
Для сбора статистики
Для изменения данных в таблицах, если в dml операции участвует представление
Для предотвращения dml операций в какие-то определенные часы
Для реализации сложных ограничений целостности данных, которые невозможно осуществить через описательные ограничения, установленные при создании таблиц
Для организации всевозможных видов аудита
Для оповещения других модулей о том, что делать в случае изменения информации в БД
Для реализации бизнес логики
Для организации каскадных воздействий на таблицы БД
Для отклика на системные события в БД или схеме
